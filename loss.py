import torch

#define loss we would use
l1_loss = torch.nn.L1Loss(reduction='sum')
l1_loss_mean = torch.nn.L1Loss(reduction='mean')
mse_loss = torch.nn.MSELoss(reduction='sum')
mse_loss_mean = torch.nn.MSELoss(reduction='mean')
bce_loss = torch.nn.BCELoss(reduction='sum')

#regression loss. It is used three times for offset, size and angle targets_regression
def get_regression_loss(box_pred, box_gt, mask, num_objs):
    reg_loss = l1_loss(l1_loss(box_pred * mask, box_gt * mask) / num_objs)
    return reg_loss

#box loss. using prediction and ground truth to generate loss
def get_box_loss(box_pred, box_gt, mask, num_objs,weight):

    box_loss = l1_loss(box_pred*mask, box_gt*mask) / (weight * num_objs)
    return box_loss


#heatmap loss. prediction is the output of network, target is generated using ground truth
def get_heatmap_loss(prediction, target, mask):  # mask comes from visible generated by lifting_network
    miu = 2.0  # =2 in paper
    theta = 4.0   # =4 in paper

    # indexes with objects
    positive_index = target.eq(1).float()
    # indexes without objects
    negative_index = target.ne(1).float()

    # loss when objects detected
    positive_loss = torch.pow(1 - prediction, miu) * torch.log(prediction) * positive_index
    # loss when objects not detected
    negative_loss = torch.pow(1 - target, theta) * torch.pow(prediction, miu) * torch.log(1 - prediction) * negative_index

    # the number of objects per image
    num_positive = positive_index.float().sum()
    positive_loss = positive_loss * mask
    negative_loss = negative_loss * mask
    # get the loss with objects
    positive_loss = positive_loss.sum()
    # get the loss without objects
    negative_loss = negative_loss.sum()

    # according to formula
    if num_positive == 0:
        return 0. - negative_loss
    else:
        return 0. - (positive_loss + negative_loss) / num_positive

#get sdf feature loss by compare predicted features and ground truth
def get_sdf_feat_loss(sdf_feat_pred, sdf_feat_gt, weight):
    sdf_feat_loss = l1_loss_mean(sdf_feat_pred, sdf_feat_gt)
    return sdf_feat_loss*weight

#get sdf loss by compare predicted sdf and ground truth
def get_sdf_loss( sdf_pred, sdf_gt, mask, weight):
    sdf_mask = mask.unsqueeze(-1).expand_as(sdf_gt)
    feat_loss = mse_loss(sdf_pred*sdf_mask, sdf_gt*sdf_mask)/(torch.nonzero(sdf_mask).shape[0])
    return feat_loss*weight

#get voxel loss by compare predicted voxel and ground truth
def get_voxel_loss(voxel_pred, voxel_gt, mask, weight):
    batch_size, channel, W, H, D = mask.shape
    voxel_mask = mask.reshape(batch_size,channel,W*H*D).permute(0,2,1)
    voxel_loss = bce_loss(voxel_pred*voxel_mask, voxel_gt*voxel_mask)/(torch.nonzero(voxel_mask).shape[0])
    return voxel_loss*weight

#get the sum of all the loss.
def get_loss(input,pca_model):
    #obtain data that needed to calcuate the loss
    pred_heatmap,pred_voxel,pred_sdf_feat,pred_boxes3d=input["predict_data"]
    gt_heatmap,gt_voxel,gt_sdf_feat,gt_sdf,gt_regression=input["ground_truth_data"]
    heatmap_weight,voxel_weight=input["weights"]
    sdf_idx,sdf_mask,sdf_feat_weight,sdf_weight=input["sdf_data"]
    latent_std,latent_mean,pca_bases,pca_mean=pca_model

    #data preparing
    reg_mask = input["reg_mask"].flatten()
    num_objs = torch.nonzero(reg_mask).shape[0] + 1e-6

    #box loss
    box_loss_ori = get_box_loss(pred_boxes3d["ori_box"], gt_regression, reg_mask, num_objs)
    box_loss_dim = get_box_loss(pred_boxes3d["dim_box"], gt_regression, reg_mask, num_objs)
    box_loss_loc = get_box_loss(pred_boxes3d["loc_box"], gt_regression, reg_mask, num_objs)
    box_loss = box_loss_ori + box_loss_dim + box_loss_loc

    #heatmap loss
    heatmap_loss = get_heatmap_loss(pred_heatmap, gt_heatmap, heatmap_weight)

    #voxel loss
    voxel_loss = get_voxel_loss(pred_voxel, gt_voxel, voxel_weight)

    #feat loss
    pts_feat_pred = pred_sdf_feat.gather(1, sdf_idx)
    pts_feat_unnormed = pts_feat_pred*latent_std + latent_mean
    feat_loss = get_sdf_feat_loss(pts_feat_unnormed, gt_sdf_feat, sdf_feat_weight)

    #sdf loss
    sdf_pred = torch.mul(pts_feat_unnormed, pca_bases) + pca_mean
    sdf_loss = get_sdf_loss(sdf_pred, gt_sdf, sdf_mask, sdf_weight)

    loss = box_loss + heatmap_loss + voxel_loss + feat_loss + sdf_loss
    return loss
